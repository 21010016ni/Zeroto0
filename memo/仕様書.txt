フィールドの上にオブジェクトを置いて、プレイヤーはフィールドの上を歩いていく
一次元フィールド
Listが並べ替えも高速なんだろうしいいのかなあ
shared_ptr<Object>をlistで持っておく
いやでも移譲でいいのか？
並べ替えの仕様について
まあ普通にsortする形式と、それぞれの位置を指定して入れ替える形式
iter_swapで良いとは思うんだけど
一回unique_ptrをswapするようにして、エラー吐いたらshared_ptrに変更
検索に関しては？　先頭から見て存在していたらそれのweak_ptrを、無いならnullptrを返す
後方検索は実装しない、指定位置から前方範囲だけ

登録するオブジェクトについては？
前やった感じだと、なんか……通り過ぎるだけの純粋イベントにもステータスとか存在してたのが無駄だった
ここはポインタで保持しておくといいのかも　そうなると、じゃあイベントとかもそういう感じでステータスを渡すように
イベント自体は確実に必要ね
画像とかは？　これステータスに紐づけた方がいいのか？

武器によるアクションなど、ある程度統合した方が楽だけどみたいなやつについては？
武器の性能を加味した一時ステータスを、攻撃アクションに渡してとかやるといいのかも
アクションによるクールタイムは？
返り値は一応、使用に成功したか（アイテムの個数を減らすか）ってところに関わるから
クールタイムは参照渡しでいいか？　あるいはpairとかそれ用の構造体とかに纏めるか
あんまり引数多いとキモいので返り値で渡そう
あれ？　アイテムはそうだ　アイテムの方でクールタイム設定してたっけ
いや……うーん　どうしよう　関数を二つ経由する形式でやると仮定するならアレなんだけど
攻撃力とかクールタイムとか、アイテム設定ファイルから読み出す？　プログラム内で定義する？
でもなあ　特定の武器だと……みたいなの実装するなら結局
んー　凝った仕様にできない（現在攻撃力の2倍のダメージとかはできない）ことを考えると、プログラム内でやった方がいいのかも
でも射程はどうしてもアイテム依存にはなるのか（アクションを実行する以前の段階で行うため）
いや……？　単独実行にすればいいのでは？
対象の検索を単独のイベントから実行するようにすれば色々解決しそう
でもそれって結局変わんなくない？　どうなんだろう
射程増強のステートが効果あるやつとないやつで分けたりはできそう
そもそもプレイヤーは射程を持たなかったら良い気はする
でもエネミーはAIの都合上射程が必要じゃない？

どういう流れになるのか

プレイヤーがアクションを実行操作
アクションの射程圏内に対象となる敵が存在した場合、その対象に実行
存在しなかった場合、プレイヤー単独で実行

あ～……そうか　敵の、複数対象のアクションで攻撃とかなんかさせて、単独行動で移動させればいいんだ
アクションは関数であるため、それ自体が射程を持つことは不可能
アクションはアイテムと必ず紐づく？　いやそんなことはない
そんなことはないが、紐づかないアクションは結局全部特定のタイミングで起動するものだから射程をそもそも持たない
じゃあアイテムが射程を持ち、それをいい感じにする感じで
敵もアイテムを使う
その場合、じゃあStatusの方に座標を入れなきゃ
違うな　座標を持ってるのはFieldの方
仮に動かせるとしてもObject
じゃあ……？？　Objectを渡すのか
ていうかそうか　Objectを渡さないとダメじゃん
あー　でもその場合ObjectがStatusを持つか否かをいちいち判定しないといけないな　まあいいか
場合によっては、Statusを持たないオブジェクトはFieldが返さないようにしてもいいし

アクション実行時
そもそも2パターンあり、最初から対象をとって実行するパターンとソロで実行するパターン
うち、対象を取るパターン
ユニークなほうのアクションから検索
存在しなかったら、共通の対象アクションを検索
それも無かったら、実行者のみでアクション
それすら無かったらエラー処理

プレイヤーはアイテムを持つ
アイテムはDataBaseクラスにvector<Item>を置いてidで参照
同じく、敵もドロップアイテムとして持つ
確定ドロップ？　なんか重みづけとかできたらいいね
まあ敵自体多分そんなに出さないような気がするし、確定でもいいのかも
敵倒すには必ずリソース削る必要があって、それなのにリターンは不確実じゃちょっと駄目
まあドロップアイテムのリストを加算する形で
で、それとは別に行動パターンとしてアイテムを持つことになる
これは敵専用のアイテムになる（射程がマイナスの為）

アイテムIDは必ず個別？　いやアイテムIDはDataBaseの登録順か
ID(アクションID)
アイコン番号

敵とか味方とかの、雛形と実体について
雛形は用意したい　が、その場合はどうする？
Statusクラスを雛形として扱う？　それとも別に実体を用意する？
別に用意した方がいい
unique_ptr<std::pair<const Status*,StatusInst>>


メニューはなんかクラスで用意する
操作についてどうする？　直に触れてもいいのか
なんかなんでエラーになるのかよくわかってないんだよな　話聞きたさある